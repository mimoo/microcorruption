# Level 14: Algiers

![algiers](img/14_1.PNG)

## Observations

* Use of the **malloc** function. Hints at a **Heap Overflow Exploit**.
* There are two functions that can unlock this level:  `unlock_door` and `test_password_valid`.
* There seem to be no check on the username and password length. We can enter 18 bytes in username and then it gets overwritten by password.
* With a quick test entering a long string of the same letter as username and as password we get an error : **load address unaligned: UU75** where UU is the character we entered in the username.
* One character in username input gets changed to ` during the password verification (at address 2422 in memory).
* The buffer overflow stops us at line 0x4520 (in the `free` function).

![observations](img/14_2.PNG)

In the Manual we find: 

> BIT arg1 arg2 -> compute arg1 & arg1, set the flags, and discard the results (like TEST on x86)

Also it seems good to keep being aware that in MSP430 the Heap grows toward the Stack and the Stack towards the Heap.

0000 low addresses
HEAP v

STACK ^
Text v
ffff high addresses

## login

Looking at the login function we see that it's doing two malloc of size 10 and is storing the username in the first malloc contained at r10, and the password in the second malloc r11.

![malloc](img/14_3.PNG)

But let's see what really happens. We can see the heap before the mallocs:

![malloc_init](img/14_5.PNG)

The heap after the first malloc:

![malloc1](img/14_6.PNG)

The heap after the second malloc:

![malloc2](img/14_7.PNG)

The heap after entering "username" as username:

![username](img/14_8.PNG)

The heap after entering "password" as password:

![password](img/14_9.PNG)

After retrieving the user's credentials. The program calls `test_password_valid` and unlocks the door or not according to the validity of the username and the password.

Looking at the test_password_valid we see an early `ret` followed by a long list of what seems like gibberish opcodes (is it a hint at ROP?).

Later the login function frees the two mallocs.

![free](img/14_4.PNG)

## Heap Structure.

![password](img/14_9.PNG)

The Heap is a **doubly-linked list**. Each chunk is composed of **metadatas** and a **payload**. Here we can see the first chunck containing the username:

```
0824 | 1e24 | 21 00 | username | 00...
 bk  |  fw  | sz/st | payload  | padding
```

And what is interesting:

* bk (backward): a pointer to the previous chunck
* fw (forward): a pointer to the next chunck

The second chunck starts at address `241e` and contains the password. The idea of a heap overflow is to **overwrite the metadatas** of this second chunck when filling the payload of the first one. Because when free is called to remove this chunck, it will do some magic with the fw and bk pointers so the chain can reconstruct around the chunck.

Here we can see the memory after the first free:

![free1](img/14_10.PNG)

And the memory after the second free:

![free2](img/14_11.PNG)

So let's change bk to our return address, and let's change fw to the address of the `unlock_door` function.