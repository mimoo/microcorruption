# Level 2: New Orleans

![new orleans](img/2_3.png)

MicroCorruption comes with a nice debugger. Writing `c` (as *continue*) in the **debugger console** runs the program and allows you to try a password.

![password](img/1_2.png)

Of course entering *password* as password doesn't work. let's type `reset` in the console and try again. The debugger creates a **breaking point** automatically after the pop-up by the way.

After a few `n` (next instruction) we end up in a `check_password` function. Obviously it is checking if the password is correct. This is where it starts.

![e](img/1_3.png)

Some explanations on the desassembly here:

* On the left you can see the addresses in the memory for each instructions. They take 16 bits of space (so we are not in a 32 or 64 bits system) and they are written in base 16 for more conveniance. 1 bit in the address maps to 1 byte of code. Also an instruction's size can vary from 1 byte to many bytes.

* After the address of the instruction you can see the instruction in hexadecimal (`0e43` on the first line). It's not very useful, at least at this level.

* Following the hexadecimal form of the instruction you have the assembly form of it. Comprised of an **opcode** (`clr` on the first line) and its **arguments** (`r14` on the first line).

In the function `check_password` the program plays with registers. Those are just place near the CPU that can be accessed very fast. You can put **one word** of anything you want in it, be it a pointer or a value. A **word** represents the space in memory you can allocate. MSP430 is a 16 bits system so a word is 16 bits.

There are other ways (and slower ways) to store and retrieve data in code execution. But we'll only work with register for this second level. Here's what the code would do if disassembled in a language more familiar (that looks like C):

```
function check_password:

r14 = 0; // clr r14
r13 = r15; // mov r15, r13
r13 += r14; // add r14, 13
// cmp.b @r13, 0x2400 and jne #0x44d2
// we compare only one byte and not an entire word
if(*r13 & 0x01 == *(0x2400 + r14) & 0x01)
{
    r14++; // inc r14
    // cmp #0x8, r14 and jne #0x44be
    // here we use cmp and not cmp.b so we compare an entire word (16 bits in MSP430)
    if(r14 != 8)
    { 
        goto check_password + 2; // go back to the mov r13 = r15 line
    }
    else
    {
        r15 = 1; // mov #0x1, r15
        return; // ret
    }
}

r15 = 0; // clr r15
return; // ret
```

> So we compare one byte of what's in r13 with one byte of what's in address r14 + 2400 (which is address 2400 since we did a `clr r14`).
Then we compare the next byte, and on and on, for 8 bytes. Then it sets r15 to 1 and return. Otherwise r15 is set to zero.

We can see later in the code that if `r15 = 0` it's a bad thing, and if it equals `1` then we're done!  
At this point we can easily guess that what is at the address 0x2400 and of length 7 bytes (followed by the \0 terminating character) must be the password. 

![memory dump](img/1_6.png)

The live **memory dump** gives us a string. We enter it as the password: it works!  
We couldn't see that without running the program because the password was created during runtime, we can see the function that does that here:

![create password](img/1_5.png)