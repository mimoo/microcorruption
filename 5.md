# Level 5: Cusco

When we entered the level, we are greeted with this a message

>- We have fixed issues with passwords which may be too long.

That's a reference to level 3 :)

## Let's start

We see that if we try to enter a long password it stores a maximum of 48bytes of it in the stack.

>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

We also see that if we continue executing the program with such a long password it stops running correctly after line `453e` which is the return instruction `ret` of the function `login`. It seems we have overwrote the instructions. A quick of the program counter (`r pc 8`) to read the next instruction shows that there are all zeros.

The `ret` instruction of a function takes the last value in stack and loads it into the Program Counter `pc` ([also called the Instruction Pointer `ip` in intel x86](http://en.wikipedia.org/wiki/Program_counter)).
What we did was overwriting the stack (**stack overflow**) and changing the **return value** of the function, which was supposed to be the next instruction.

## Where is the value we have to change?

Okay, so where exactly is this value we had to change? I will enter "password" as password so I can quickly find it in the memory, and break on the `ret` instruction so I know where in the stack it will take its next value (`b 453e`).

![image](img/4_1.PNG)

Here we see that `pc` was pointing to `453e`, and after the return it points to qddress `443c` in memory, which was indeed the last 16bits entry of the stack, located 8bytes after our "password" (we can see that in the Live Memory Dump). Now we know that if we enter a password where the 16th byte is 0xaabb, the program will load the instruction located at address 0xbbaa in memory (remember, we are in little endian).

## What should we load?

What about that function called `unlock_door`? Let's try to jump to that and see if it does what it says.

Let's try with that password: `0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4644`

**It works!**